#summary Command-query Responsibility Segregation - System Architect mental model
<wiki:toc max_depth="3" />
= Introduction =
This document describes sample code illustrating CqRS techniques. Intention is to present code form the perspective of the (application/system/general) architect. So we focus on architects' mental model digging deep into engine details. 

Idea is that an architect need to understand what's under the hood - he or she should feel with engine technical code like fish in the water and freely change it.

==Architecture and design visualization using Scalable Map==

Java (and any known language) does not support understanding complex code structures. Neither UML tools.

Therefore, using [http://prezi.com Prezi], we have created a "scalable map" of both big picture (architecture) and details view (class design).

  * You can watch it [http://prezi.com/hi2dmhfej9zu/ddd-cqrs-sample-2/ here]
  * You can "play" default road trip or pan and zoom freely using mouse
  * You can click on SVN link and go straight to the code!


----
----

=Portable architecture - technical independence=
Application architecture is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Application_Architecture Part I: DDD - Application Architecture].

Portable architecture idea is described in [Philosophy#Portable_architecture_-_technical_independence Philosophy chapter].

Possibility to switch Spring to other container or light and simple home made solution is described in this document in section [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Run_Environment_-_leaven_for_additional_features Run Environment - leaven for additional features].

Possibility to implement own Events is described in this document in section [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Events_Engine Events Engine].

Possibility to implement own Saga is described in this document in section [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Saga_Engine Saga Engine].


----
----

=Architecture decisions= 
==Business (Write) Model==
Application Layer responsibility from the Business Developer perspective is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Application_Layer DDD Part].

Implementing Business Stack, Application Layer You can choose between: classic service style and command+handler style.


===Classic: Service - AOP techniques===
Sample [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/services/PurchaseApplicationService.java PurchaseApplicationService] is annotated with @ApplicationService annotation.

@ApplicationService annotation is annotated with Spring annotations.

<code language="java">
@Service
@Transactional
//@Secured
public @interface ApplicationService {
    String value() default "";
}
</code>

In result all Application Services gain Spring features 
  * Dependency Injection
  * Services can be injected into upper layer components
  * Transactions and Security provided via transparent AOP mechanisms.

===Commands and handlers===
Sample command is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Commands_and DDD Part].

CommandHandlers are automatically matched to incoming Commands by generic type of the Handler.

<code language="java">
public interface CommandHandler<C, R> {
    public R handle(C command);
}
</code>

for example this handler:
<code language="java">
@CommandHandlerAnnotation
public class SubmitOrderCommandHandler implements CommandHandler<SubmitOrderCommand, Void> {
  //..
}
</code>
is matched to handle this command:
<code language="java">
@Command(unique=true)
public class SubmitOrderCommand {
 //..
}
</code>


Matching engine is implemented in [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/spring/SpringHandlersProvider.java SpringHandlersProvider] class.

Idea is quite simple:
  * Each CommandHandler is annotated with @CommandHandlerAnnotation what makes it a Spring Bean
  * Our provider object reacts on Spring internal event that is fired after Spring context refresh - onApplicationEvent method
  * Provider scans Spring Context looking for CommandHandlers
  * For each found Hander we simply check it's generic type
  * Provider registers in inner HashMap Type of the command and the Spring bean name (name of the handler)
  * When asked about handler for given command - getHandler method
    * return Spring bean

As You can see mechanism is really simple.
You can implement Your own CommandHandler provider using any container You like (or even using home made XML, Annotations or just hardcoded map;)

===Synergy: Commands and AOP=== 
We have decided to mix CommandHandler approach with Spring's AOP goodies.

Each CommandHandler is annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java CommandHandlerAnnotation] annotation.
<code language="java">
@Component
@Transactional
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CommandHandlerAnnotation {
}
</code>

CommandHandlerAnnotation is annotated with Spring's annotations. Therefore executing any CommandHandler results in running all Spring AOP engine that supports Transactions and Security. You can also inject dependencies to each handler.

If You would like to get rid of Spring and provide own implementations of this features refer to [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Run_Environment_-_leaven_for_additional_features Run Environment - leaven for additional features] chapter.
---
==Presentation (Read) Model== 
Presentation Stack responsibility from the Business Developer perspective is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Presentation_Stack DDD part].


===Performance problems with JPA===
  TODO
  * n+1 Select problem
  * fetching unnecessary data
  * need to encapsulate domain model (remote clients)
    * loading JPA entities and repacking to DTO is simply silly:)
===Techniques of flattening Business Model===
  TODO
  * JPA: SELECT NEW
  * Native SQL
  * materialized ViewView
  * Dedicated Model
===Optimization: First think what You query for, tan model it ===
TODO
====Dedicated model updated by Domain Events====
Dedicated model updated by Domain Events from the Business Developer perspective is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Updating_read_model DDD Part].

====Shredding====

====Clustering====

====Cloud==== 
---
==Event Sourcing== 
===When to Use===
  * Need to store Behavioral model and "project" it in many perspetives
  * Complex Event Processing with Artificial Neural Networks (events stream as learning vector)
  * Need to "travel in time"
===Why in this context we decided to not use it=== 
  * ERP is well described by archetypes
  * Relative small amount events per aggregate
  * Need to check model constrains - relational DB does it out of the box

----
----

=Technical aspects of implementation= 
TODO

==Command Handlers== 
===Finding Handler=== 
===Security and transactions===

---- 
==Server Gate== 
===Asynchronous mode=== 
===Optimization by detecting duplicates===

----
==Run Environment - leaven for additional features== 


==Events Engine== 
===How doest it work and why so simple:) ===
===Asynchronous Mode ===

----

==Saga Engine== 
===Also so simple? ===
===API ===
===Persistent Memento===