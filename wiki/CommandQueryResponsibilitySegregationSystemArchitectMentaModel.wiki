#summary Command-query Responsibility Segregation - System Architect mental model
<wiki:toc max_depth="3" />
= Introduction =
This document describes sample code illustrating CqRS techniques. Intention is to present code form the perspective of the (application/system/general) architect. So we focus on architects' mental model digging deep into engine details. 

Idea is that an architect need to understand what's under the hood - he or she should feel with engine technical code like fish in the water and freely change it.

==Architecture and design visualization using Scalable Map==

Java (and any known language) does not support understanding complex code structures. Neither UML tools.

Therefore, using [http://prezi.com Prezi], we have created a "scalable map" of both big picture (architecture) and details view (class design).

  * You can watch it [http://prezi.com/hi2dmhfej9zu/ddd-cqrs-sample-2/ here]
  * You can "play" default road trip or pan and zoom freely using mouse
  * You can click on SVN link and go straight to the code!


----
----

=Portable architecture - technical independence=
Application architecture is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Application_Architecture Part I: DDD - Application Architecture].

Portable architecture idea is described in [Philosophy#Portable_architecture_-_technical_independence Philosophy chapter].

Possibility to switch Spring to other container or light and simple home made solution is described in this document in section [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Leaven_for_additional_features Run Environment - leaven for additional features].

Possibility to implement own Events is described in this document in section [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Events_Engine Events Engine].

Possibility to implement own Saga is described in this document in section [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Saga_Engine Saga Engine].


----
----

=Architecture decisions= 
==Business (Write) Model==
Application Layer responsibility from the Business Developer perspective is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Application_Layer DDD Part].

Implementing Business Stack, Application Layer You can choose between: classic service style and command+handler style.


===Classic: Service - AOP techniques===
Sample [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/services/PurchaseApplicationService.java PurchaseApplicationService] is annotated with @ApplicationService annotation.

@ApplicationService annotation is annotated with Spring annotations.

<code language="java">
@Service
@Transactional
//@Secured
public @interface ApplicationService {
    String value() default "";
}
</code>

In result all Application Services gain Spring features 
  * Dependency Injection
  * Services can be injected into upper layer components
  * Transactions and Security provided via transparent AOP mechanisms.

===Commands and handlers===
Sample command is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Commands_and DDD Part].



===Synergy of Commands and AOP=== 
We have decided to mix CommandHandler approach with Spring's AOP goodies.

Each CommandHandler is annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java CommandHandlerAnnotation] annotation.
<code language="java">
@Component
@Transactional
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CommandHandlerAnnotation {
}
</code>

CommandHandlers are automatically matched to incoming Commands by generic type of the Handler.

<code language="java">
public interface CommandHandler<C, R> {
    public R handle(C command);
}
</code>

for example this handler:
<code language="java">
@CommandHandlerAnnotation
public class SubmitOrderCommandHandler implements CommandHandler<SubmitOrderCommand, Void> {
  //..
}
</code>
is matched to handle this command:
<code language="java">
@Command(unique=true)
public class SubmitOrderCommand {
 //..
}
</code>

CommandHandlerAnnotation is annotated with Spring's annotations. Therefore executing any CommandHandler results in running all Spring AOP engine that supports Transactions and Security. You can also inject dependencies to each handler.

If You would like to get rid of Spring and provide own implementations of this features refer to [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Leaven_for_additional_features Run Environment - leaven for additional features] chapter.
---
==Presentation (Read) Model== 
Presentation Stack responsibility from the Business Developer perspective is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Presentation_Stack DDD part].


===Performance problems with JPA===
  TODO
  * n+1 Select problem
  * fetching unnecessary data
  * need to encapsulate domain model (remote clients)
    * loading JPA entities and repacking to DTO is simply silly:)
===Techniques of flattening Business Model===
  TODO
  * JPA: SELECT NEW
  * Native SQL
  * materialized ViewView
  * Dedicated Model
===Optimization: First think what You query for, tan model it ===
TODO
====Dedicated model updated by Domain Events====
Dedicated model updated by Domain Events from the Business Developer perspective is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Updating_read_model DDD Part].

====Shredding====

====Clustering====

====Cloud==== 
---
==Event Sourcing== 
===When to Use===
  * Need to store Behavioral model and "project" it in many perspetives
  * Complex Event Processing with Artificial Neural Networks (events stream as learning vector)
  * Need to "travel in time"
===Why in this context we decided to not use it=== 
  * ERP is well described by archetypes
  * Relative small amount events per aggregate
  * Need to check model constrains - relational DB does it out of the box

----
----

=Technical aspects of implementation= 
==Command Handlers== 
===Finding Handler=== 

Matching engine is implemented in [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/spring/SpringHandlersProvider.java SpringHandlersProvider] class.

Idea is quite simple:
  * Each CommandHandler is annotated with @CommandHandlerAnnotation what makes it a Spring Bean
  * Our provider object reacts on Spring internal event that is fired after Spring context refresh - onApplicationEvent method
  * Provider scans Spring Context looking for CommandHandlers
  * For each found Hander we simply check it's generic type
  * Provider registers in inner HashMap Type of the command and the Spring bean name (name of the handler)
  * When asked about handler for given command - getHandler method
    * return Spring bean

As You can see mechanism is really simple.
You can implement Your own CommandHandler provider using any container You like (or even using home made XML, Annotations or just hardcoded map;)

===Security and transactions===
Command + CommandHandler matching sample is described in [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Synergy_of_Commands_and_AOP Synergy of Commands and AOP] chapter.

Each CommandHandler is annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java @CommandHandlerAnnotation].

<code language="java">
@Component
@Transactional
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CommandHandlerAnnotation {
}
</code>

CommandHandlerAnnotation is annotated with Spring's annotations:
  * @Component - what makes it a Spring Bean. You can inject dependencies to the handler
  * @Transactional - transactions are automatically managed by Spring's Transaction Manger according to System/Application Exception convention (refer to the Spring documentation).
  * You can add Spring's @Secured annotation to introduce security aspect

----

==Server Gate==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Gate.java Gate] class is the first point of access to the Application Layer. It's responsibility is to dispatch Command.

It should be called by:
  * web app controllers that sends Commands
  * all clients from Client Tier that sends Commands

Gate itself is a Spring Component so it can be injected into web app controllers.

In standard case Gate simply delegates command handling to the [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Run_Environment RunEnvironment].

===Asynchronous mode=== 
Commands *can* be annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Command.java Command] annotation.

You can specify *asynchronous* attribute of this annotation.
<code language="java">
@Command(asynchronous=true)
public class MyCommand {
  //..
}
</code>
In this case Gate does not delegate Command to the [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Run_Environment RunEnvironment]. Gate sends command to the queue and returns immediately to the client.

Responsibility of the queue is to send asynchronously command to the technical Listener, that calls [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Run_Environment RunEnvironment] at the end.

*This feature is not implemented Yet in this Leaven, but idea is straight forward.*

===Optimization by detecting duplicates===
As mentioned in previous section, Commands *can* be annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Command.java Command] annotation.

You can specify *unique* attribute of this annotation.
<code language="java">
@Command(unique=true)
public class MyCommand {
  //..
}
</code>
You *can* also specify uniqueStorageTimeout property.
 
Sample code: [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/SubmitOrderCommand.java SubmitOrderCommand] class.
Sample scenario: nervous user keep clicking Approve Order button and client app does not block it.

This is the way of expressing the following intention:
 Sending the same command again (eventually in given time window) is a mistake, please ignore this. Command is the same if equals method says so (so You must implement if if specifying unique=true).

This is just a tip for a server to use it's internal [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/GateHistory.java GateHistory].
Therefore server does not even have to struggle with Command Handling.

*WARNING*
This is just an optimization technique and You can not rely on it. Simply GateHistory could be filled to max and lost it's old entries.
You always have to perform checking in Domain Logic of this operation can be executed.

----
==Run Environment==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/RunEnvironment.java RunEnvironment] class is actual place that runs Commands. Actually it matches CommandHandler to the Command using [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Finding_Handler provider] and runs Commandhandlers.

You should use this class in the following situations:
  * in the [CommandQueryResponsibilitySegregationSystemArchitectMentaModel#Server_Gate Gate]
  * in the Queue technical Listener/MessageDrivenBean that handles asynchronous commands
  * when executing commands in Application Listeners described in [DomainDrivenDesignBusinessDeveloperMentalModel#Listeners_-_Bounded_Context_and_Context_Mapper DDD Part]

RunEnvironment impl is quite trivial.
It simply:
  # finds proper Handler using injected HandlersProvider
  # runs found Handler

===leaven for additional features===
Simplicity drives form Spring goodies that cares about everything (Security, Transactions).

But You can get rid of Spring simply adding technical code before and after
<code language="java">
Object result = handler.handle(command);
</code>

You can add:
  * transaction management (begin, end, rollback)
  * authentication and authorization
  * command execution logging
  * storing commands
  * command execution profiling
  * etc
All this must be done only in this one place.

You can also implement Your own HandlersProvider.
----

==Events Engine== 
===How doest it work and why so simple:) ===
===Asynchronous Mode ===

----

==Saga Engine== 
===Also so simple? ===
===API ===
===Persistent Memento===