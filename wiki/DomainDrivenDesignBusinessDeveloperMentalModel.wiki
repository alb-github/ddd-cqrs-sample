#summary Domain Driven Design - Business Developer mental model

<wiki:toc max_depth="2" />

= Technical introduction =

This document describes sample code illustrating DDD techniques. Intention is to present code form the perspective of the business model developer. So we focus on business developers' mental model without digging to deep into engine details.

Idea is that Business does not need to understand what's under the hood - he or she should rather focus on modeling and well crafted business code.

==Architecture and design visualization using "scalable map"==

Java (and any known language) does not support understanding complex code structures. Neither UML tools.

Therefore, using [http://prezi.com Prezi], we have created a "scaleable map" of both big picture (architecture) and details view (class design).

  * You can watch it [http://prezi.com/hi2dmhfej9zu/ddd-cqrs-sample-2/ here]
  * You can "play" default road trip or pan and zoom freely using mouse
  * You can click on SVN link and go straight to the code!

==Project Structure==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample SVN Repository] contains project that is structured in the standard Maven way.

===DDD common classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd pl.com.bottega.ddd] contains common DDD library (not framework).

Common DDD goodies are:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fapplication application]
    * annotation - annotations used in Application Layer artifacts
      * !ApplicationEvent - tagging annotation, will be used in visual tools
      * !ApplicationService - if You prefer services instead of commands and handlers. Used for tagging but also provides Spring features (this annotations is annotated by Spring annotations)
      * !ApplicationStatefullComponent - for session scoped Spring beans
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain domain]
    * annotations - annotations for all DDD Building Blocks - some of them are just for tagging (will be used by visual analyzers) but some of them are annotated by Spring's annotations that introduces Spring based features like being a Bean. All annotations will be described in details in [DomainDrivenDesignBusinessDeveloperMentalModel#Domain_Layer Domain Layer section] of this document.
    * sharedcernel - common model used in all Bounded Contexts
    * infrastructure
      * events - Events Engine impl, Common technical listeners, annotations for listeners
      * repo - JPA base repositories, that can be handfull
      * sagas - Saga Engine impl
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fsagas sagas] - Saga API - described in later section of this document


===CqRS common classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fcqrs pl.com.bottega.cqrs] contains common CqRS "engine".

Common CqRS goodies are described in the [PART II] because they are just technical details.

===ERP product classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp pl.com.bottega.erp] is The Product - Enterprise Resource Planning class system.

System modules separation at this package level:
  * crm - Client Relationship Management module
  * sagas - Sagas which contains cross module features
  * sales - Sales module - *most examples are implemented in this module*
  * shipping - Shipping module

Modules are independent set of features that can  be used separately and still being valuable.

In this sample modules are equal to DDD Bounded Context.

===ERP module structure===
Open [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales Sales] module, look at packages structure and follow the description:

Each module is packaged using the same application architecture style (beginning from the top):
  # _webui_ - at the top, web client controllers
  # two separated CqRS stacks:
    * read (presentation) model
      # _presentation_ reading presentation data
    * write (business) model
      # _application_ application logic (handlers or services, listeners, statefull objects)
      # _domain_ - domain model, building blocks
      # _infrastructure_ - technical stuff, repository impl, technical listeners

===Technical resources===
Folder [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fresources] contains:
  * jdbc and logger properties
  * application service level (no web app stuff) Spring configuration

Folder [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fwebapp] contains web application based on Spring Web MVC. Other client implementations will be provided in the next milestone (Android, Ajax, Remoting, WebService)

==Just one Maven Artifact?==
As You can see project logically contains:
  * common DDD API
  * common DDD impl
  * common CqRS API
  * common CqRS impl
  * product modules API
  * product modules and cross module Sagas impl

All this stuff is stored in one Eclipse Project - one Maven Artifact.

This decision is a trade-off made in sake of simplicity. If You are proficient Maven user, You probably split code into separated artifacts in one hour. But those of You who are not familiar with Maven should focus on the essence of this project - sample code.

----

=Domain Description=
Sample is illustrated in the context of simplified fraction of the ERP system. We have chosen some ERP domains because they are relatively well known. Everybody has some intuition about Clients, Orders, Products etc. so We don't have to stuck explaining how different domain works (financial, medical etc.)

==Bounded Contexts==
There are three Bounded Context, that are equals to the ERP modules.
This approach:
  * helps to model that is relevant to the specific context
  * supports focus on specific Domain Expert knowledge area
  * avoids creating one big corporate model of Great Unification theory that is de'facto meaningless.

Modules are separated at the level of [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp pl.com.bottega.erp] package.

===Sales===
It's about ordering products, calculating rebates, invoicing and analyzing sale trends.
This module contains most sample code. Other modules just illustrates Event communication and are Saga participants.
===CRM===
It's about client relationship management. Client in this module is modeled as a different artifact (another Bounded Context) than in Sales module.
===Shipping===
It's about charging and shipping orders.

==Shared Kernel== 
Shared Kernel contains model common to all Bounded Contexts - [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fsharedcernel pl.com.bottega.ddd.domain.sharedcernel] package.

==WARNING==
ERP model is simplified in sake of educational purpose. If You are developing such a system refer to [Introduction#Modeling_resources Modeling Resources], in particular:
  * Party Archetype
  * CRM Archetype
  * Product Archetype
----

=Application Architecture=
Looking at the [DomainDrivenDesignBusinessDeveloperMentalModel#Architecture_and_design_visualization_using_"scalable_map&q Visual Map] should be helpful in this moment. 
==Two stacks of Layers== 
Each module is build regarding the same architecture style.
Three tier architecture:
* Client Tier
* Application Server Tier
* DB Tier

Application Server Tier is designed in layered fashion (remember that Tier!=Layer). Layer are grouped in two stacks.
One stack specialized in domain modeling and handling commands, second specialized in fast data serving and handling queries.

CqRS convention is to call one stack: Write Model  and second: Read Model. But we prefer call it *Business* and *Presentation* models because in Business model You bot write and read data (read data are just not visually presented, used only in processing).

There are Clients on the top of both stacks. Right now only WebApp client is implemented.
Client Tier code located is here:
http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fwebapp

Server Tier code (Sales Module) is located here:
http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fwebui

Looking at the Server Tier Let's focus on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales Sales Module].

application application logic (handlers or services, listeners, statefull objects)
domain - domain model, building blocks
infrastructure - technical stuff, repository impl, technical listeners

===Presentation Stack===
Presentation (read) model is simple. It's just a thin layer specialized in reading data that need to to presented somehow.

[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fpresentation pl.com.bottega.erp.sales.presentation] Package contains sample:
  * Queries - Search Criteria objects that specify querying parameters.
Notice that [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/presentation/ProductSearchCriteria.java ProductSearchCriteria] class is designed in Fluent Interface style. From the client perspective criteria hides domain model properties (name, description) under abstract text.
  * Data Transfer Objects - carries data. They are created per Use Case/User Story or per View. In complex systems they are much better transferring classes than JPA entities because they don't break encapsulation on the model level and contains optimized data that are needed in particular context.
  * Finders - simple services that perform search based on Search Criteria.

In [PART II] we will discuss:
  * Technical details of designing this Stack
  * Techniques of optimization (Special JPA Syntax, pure SQL, Updating by Events, Materialized Views)

===Business Stack===
Business tack layers are described in details in the following sections:
[DomainDrivenDesignBusinessDeveloperMentalModel#Application_Layer Application Layer]
[DomainDrivenDesignBusinessDeveloperMentalModel#Domain_Layer Domain Layer]
[CqRS_Part_II Infrastructure]

==Expressing Design using Custom Annotations==  
While reading the sample code You should notice multiple custom annotations, used to mark
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fannotations DDD Building Blocks]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fapplication%2Fannotation Application Layer objects]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fsagas Sagas]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents Events]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Command.java Commands]

Annotations are used to achieve three goals:
  * Tag code - visual analyzer (similar to "scaleable map") will be reading them and presenting design graph
  * Some custom annotations are annotated by Spring's annotation. In effects classes annotated by custom annotations gains Spring features (transactions and security). Using custom annotations decouples and globalizes Spring features.
  * CqRS engine (Event, Sagas) rely on some custom annotations.

All custom annotations will be described in details in later sections of this document.


==Inversion of Control techniques==
Application architecture of this sample rely in Inversion of Control principle - famous Hollywood rule: "Don't call Us, we will call You".

It is important to notice that Spring can be easily removed and all it's features can be implemented on Your own.

*Spring features are encapsulated by custom annotations and interfaces.
Implementing IoC features on Your own is described in PART II.*

===Dependency Injection===
DI is basic IoC technique. In this project DI is used only at the application level:
  * Injecting dependencies (Repositories, Services) to Command Handlers
  * Injecting dependencies (Repositories, Services) to Application Services -  If You want to use classic services approach without commands
  * Injecting dependencies (JDBC connection, Entity Manager) to repositories
  * Injecting dependencies (JDBC connection, Entity Manager) to Finders (presentation stack) 

We decided not to inject automatically dependencies to Aggregates. It could be done using Spring's @Configurable but we wanted to keep example magic clear. This trade-off makes easy rewrite our Leaven to different platform (Seam, EJB, etc.) 

===Events===
Events are stronger than DI technique of inverting control, because they allow to:
  * abstract number of dependencies (many listeners)
  * decouple from time arrow (asynchronous)

We have decided to implement own [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents Event Engine], because Spring's solution forces You to use Spring specific API.

Event engine contains:
  * two [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents annotations]
    * EventListener - for listener methods
    * EventListeners - for class containing listener methods - adds Spring Comonent features (DI)
  * just two [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents%2Fimpl impl classes]

So Events Engine can be easily enhanced to support asynchronous processing secured by persistent queue.

===Aspect Oriented Programming===
AOP is the strongest IoC technique used int the sample to provide:
  * transactions
  * security

You can use Command style or classic Application Service style. Simply use [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationService.java ApplicationService] or [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java CommandHandler] annotation - they both introduces Spring Security and Transaction Management features.

But implementing own "AOP" *is trivial* when using Command style. Simply edit [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/RunEnvironment.java RunEnvironment] class and add own features before and after running a handler.


----

=Application Layer= 

Application logic orchestrates scenario for "domain actors" who lives in lower layer. Application logic also takes care for security and transactions. Application logic can fire application events.
 
We will discuss all sample Application Layer artifacts focusing on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fapplication Sales Module].

==Commands/Services== 
Leaven supports two styles of implementing Application Logic.
Commands and App Services are technically totally different, but mentally can be considered as equivalent.
Commands are powerful because it's relatively easy to introduce own "AOP" programming model in clean and no-magic way. Using Spring you can achieve the same feature, but in transparent, magic way. So if magic scares You or You like to have full control - choose Commands style.

===Application Services===
At first let's look at the "service" style approach.
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/services/PurchaseApplicationService.java PurchaseApplicationService]

Characteristic:
  * Repository and Factory injection
  * ApplicationEvent Publisher injection
  * SystemUser - statefull (session scoped) application object injection
  * transactions and security features supported by Spring using custom [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationService.java ApplicationService] annotation
  * Service methods realizes parts of User Story/Use Case

Typical method implementation:
  * Load Aggregates from Repositories (or create in Factories)
  * Perform business scenario (sequence of aggregate calls)
  * Eventually create Application Event
  * Save Aggregates in Repository

===Commands and CommandHandlers===
Alternative to the class "service" style is a "command" style.
You always implement a pair - command and it's handler, for example:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/SubmitOrderCommand.java SubmitOrderCommand]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/handlers/SubmitOrderCommandHandler.java SubmitOrderCommandHandler]

or
* [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/CreateOrderCommand.java CreateOrderCommand]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/handlers/CreateOrderCommandHandler.java CreateOrderCommandHandler]


Conceptually two classes can be considered as a [http://en.wikipedia.org/wiki/Command_pattern Command Design Pattern]. In our case commands are sent from different Tier, so they can not contain any logic due the security and coupling reason. Therefore Command Design pattern is split to:
  * Command that just caries input data (kind of DTO)
  * CommandHandler that contains logic.

====Command====
Creating command is simple:
  * usually implement Serializable tagging interface because command may be send form remote client
  * add fields that holds command parameters
  * You *can* add [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Command.java @Command] annotation if You want to express following intentions:
    * Client is not interested in immediate result - command can be handled in asynchronous way. This is just a suggestion for a Server - it can support asynch. invocations. Use this mode when You want to optimize response time
    * Command is unique and sending it again is considered as a mistake (ex. nervous user clicking many times). Server stores some amount of commands (annotated as unique) that were ran, therefore it can optimize anti-flood mechanism. *This feature is just in sake of optimization. You must implement unique checking on the domain level* (ex. Order can not be accepted twice). Unique mechanism rely on equals method.
    * Unique command can specify how long it should be considered as unique.
====CommandHandler====
Creating a handler for a command is also pretty straightforward.
  * implement [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandler.java CommandHandler] interface. This interface is generic, so You must specify:
    * class of the Command that is handled - CqRS engine matches Command and Handlers by this parameter
    * result type - handling command may return something to the caller. Of course handler that handle asynchronous commands should return java.lang.Void (not the void keyword).
  * You *can* annotate handler with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java CommandHandlerAnnotation] if You wan to rely on automatic  Command2Handler matching. This annotation also introduces Spring features (Dependency Injection, Security and Transactions) to the handler so You don't need to worry about them.

Now implement logic just the same way as in classic [DomainDrivenDesignBusinessDeveloperMentalModel#Application_Services Application Service]: inject required dependencies and orchestrate part of the Use Case/user Story scenario in handle method based on parameters from the Command. You can also fire an Application Event.

==Application Event==
Application Events are characteristic to the specific Use Case/User Story. They model application (not domain) behavior.

To fire such an event simply:
  * inject [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/ApplicationEventPublisher.java ApplicationEventPublisher] to the Command Handler or Application Service
  * create event using any class
    * event usually carries some valuable ingormation
    * event class *can* be annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationEvent.java ApplicationEvent] annotations - consider this as a meta-data that will be analyzed by some cools tools we plan to publish

In our example application event [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/events/ProductAddedToOrderEvent.java ProductAddedToOrderEvent] models important fact of the application life cycle. Let's assume that in this sample we don't want to model this act on the domain model level.

Than, [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/presentation/listeners/ProductEventsListener.java one of the listeners] stores data about this fact in "spy model" used by the marketing division to do something evil.

==Listeners - Bounded Context and Context Mapper== 
==Sagas== 

----

=Domain Layer= 
==Entity==
===Base class===
==Aggregate==
===Dependency Injection===
===Encapsulation===
===Outside Projections using Value Objects===
===JPA aspects===
===Base classes=== 
==Value Objects==
===Make explicit what is implicit===
===Increase expression power===
===JPA aspects=== 
==Factory==
===Dependency Injection Responsibility===
===Validation===
===Part of business logic (Assembling objects)===
===Increase testability=== 
==Repository==
===Dependency Injection Responsibility===
===Base Classes=== 
==Domain Services==
===Responsibility Driven Design Transformers===
===When to introduce: simple rule of the thumb=== 
==Policy==
===Supple Design===
===Decorating technique===
===Functional style===
===Injecting=== 
==Specification==
===Supple Design in Runtime 
==Events==
===Decoupling===
===Optimization===
===Plugin oriented architecture===
===Updating read model===
----
=Saga=
==Persistent multi-listener==
==Complex process orchestration==
==Make explicit what is implicit==