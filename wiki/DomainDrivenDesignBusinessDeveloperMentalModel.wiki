#summary Domain Driven Design - Business Developer mental model

<wiki:toc max_depth="2" />

= Technical introduction =

This document describes sample code illustrating DDD techniques. Intention is to present code form the perspective of the business model developer. So we focus on business developers' mental model without digging to deep into engine details.

Idea is that business developers does not need to understand what's under the hood - he or she should rather focus on modeling and well crafted business code.

==Architecture and design visualization using "scalable map"==

Java (and any known language) does not support understanding complex code structures. Neither UML tools.

Therefore, using [http://prezi.com Prezi], we have created a "scaleable map" of both big picture (architecture) and details view (class design).

  * You can watch it [http://prezi.com/hi2dmhfej9zu/ddd-cqrs-sample-2/ here]
  * You can "play" default road trip or pan and zoom freely using mouse
  * You can click on SVN link and go straight to the code!

==Project Structure==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample SVN Repository] contains project that is structured in the standard Maven way.

===DDD common classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd pl.com.bottega.ddd] contains common DDD library (not framework).

Common DDD goodies are:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fapplication application]
    * annotation - annotations used in Application Layer artifacts
      * !ApplicationEvent - tagging annotation, will be used in visual tools
      * !ApplicationService - if You prefer services instead of commands and handlers. Used for tagging but also provides Spring features (this annotations is annotated by Spring annotations)
      * !ApplicationStatefullComponent - for session scoped Spring beans
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain domain]
    * annotations - annotations for all DDD Building Blocks - some of them are just for tagging (will be used by visual analyzers) but some of them are annotated by Spring's annotations that introduces Spring based features like being a Bean. All annotations will be described in details in [DomainDrivenDesignBusinessDeveloperMentalModel#Domain_Layer Domain Layer section] of this document.
    * sharedcernel - common model used in all Bounded Contexts
    * infrastructure
      * events - Events Engine impl, Common technical listeners, annotations for listeners
      * repo - JPA base repositories, that can be handfull
      * sagas - Saga Engine impl
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fsagas sagas] - Saga API - described in later section of this document


===CqRS common classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fcqrs pl.com.bottega.cqrs] contains common CqRS "engine".

Common CqRS goodies are described in the [PART II] because they are just technical details.

===ERP product classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp pl.com.bottega.erp] is The Product - Enterprise Resource Planning class system.

System modules separation at this package level:
  * crm - Client Relationship Management module
  * sagas - Sagas which contains cross module features
  * sales - Sales module - *most examples are implemented in this module*
  * shipping - Shipping module

Modules are independent set of features that can  be used separately and still being valuable.

In this sample modules are equal to DDD Bounded Context.

===ERP module structure===
Open [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales Sales] module, look at packages structure and follow the description:

Each module is packaged using the same application architecture style (beginning from the top):
  # _webui_ - at the top, web client controllers
  # two separated CqRS stacks:
    * read (presentation) model
      # _presentation_ reading presentation data
    * write (business) model
      # _application_ application logic (handlers or services, listeners, statefull objects)
      # _domain_ - domain model, building blocks
      # _infrastructure_ - technical stuff, repository impl, technical listeners

===Technical resources===
Folder [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fresources] contains:
  * jdbc and logger properties
  * application service level (no web app stuff) Spring configuration

Folder [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fwebapp] contains web application based on Spring Web MVC. Other client implementations will be provided in the next milestone (Android, Ajax, Remoting, WebService)

==Just one Maven Artifact?==
As You can see project logically contains:
  * common DDD API
  * common DDD impl
  * common CqRS API
  * common CqRS impl
  * product modules API
  * product modules and cross module Sagas impl

All this stuff is stored in one Eclipse Project - one Maven Artifact.

This decision is a trade-off made in sake of simplicity. If You are proficient Maven user, You probably split code into separated artifacts in one hour. But those of You who are not familiar with Maven should focus on the essence of this project - sample code.

----
----

=Domain Description=
Sample is illustrated in the context of simplified fraction of the ERP system. We have chosen some ERP domains because they are relatively well known. Everybody has some intuition about Clients, Orders, Products etc. so We don't have to stuck explaining how different domain works (financial, medical etc.)

==Bounded Contexts==
There are three Bounded Context, that are equals to the ERP modules.
This approach:
  * helps to model that is relevant to the specific context
  * supports focus on specific Domain Expert knowledge area
  * avoids creating one big corporate model of Great Unification theory that is de'facto meaningless.

Modules are separated at the level of [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp pl.com.bottega.erp] package.

===Sales===
It's about ordering products, calculating rebates, invoicing and analyzing sale trends.
This module contains most sample code. Other modules just illustrates Event communication and are Saga participants.
===CRM===
It's about client relationship management. Client in this module is modeled as a different artifact (another Bounded Context) than in Sales module.
===Shipping===
It's about charging and shipping orders.

==Shared Kernel== 
Shared Kernel contains model common to all Bounded Contexts - [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fsharedcernel pl.com.bottega.ddd.domain.sharedcernel] package.

==WARNING==
ERP model is simplified in sake of educational purpose. If You are developing such a system refer to [Introduction#Modeling_resources Modeling Resources], in particular:
  * Party Archetype
  * CRM Archetype
  * Product Archetype
----
----

=Application Architecture=
Looking at the [DomainDrivenDesignBusinessDeveloperMentalModel#Architecture_and_design_visualization_using_"scalable_map&q Visual Map] should be helpful in this moment. 
==Two stacks of Layers== 
Each module is build regarding the same architecture style.
Three tier architecture:
* Client Tier
* Application Server Tier
* DB Tier

Application Server Tier is designed in layered fashion (remember that Tier!=Layer). Layer are grouped in two stacks.
One stack specialized in domain modeling and handling commands, second specialized in fast data serving and handling queries.

CqRS convention is to call one stack: Write Model  and second: Read Model. But we prefer call it *Business* and *Presentation* models because in Business model You bot write and read data (read data are just not visually presented, used only in processing).

There are Clients on the top of both stacks. Right now only WebApp client is implemented.
Client Tier code located is here:
http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fwebapp

Server Tier code (Sales Module) is located here:
http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fwebui

Looking at the Server Tier Let's focus on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales Sales Module].

application application logic (handlers or services, listeners, statefull objects)
domain - domain model, building blocks
infrastructure - technical stuff, repository impl, technical listeners

===Presentation Stack===
Presentation (read) model is simple. It's just a thin layer specialized in reading data that need to to presented somehow.

[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fpresentation pl.com.bottega.erp.sales.presentation] Package contains sample:
  * Queries - Search Criteria objects that specify querying parameters.
Notice that [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/presentation/ProductSearchCriteria.java ProductSearchCriteria] class is designed in Fluent Interface style. From the client perspective criteria hides domain model properties (name, description) under abstract text.
  * Data Transfer Objects - carries data. They are created per Use Case/User Story or per View. In complex systems they are much better transferring classes than JPA entities because they don't break encapsulation on the model level and contains optimized data that are needed in particular context.
  * Finders - simple services that perform search based on Search Criteria.

In [PART II] we will discuss:
  * Technical details of designing this Stack
  * Techniques of optimization (Special JPA Syntax, pure SQL, Updating by Events, Materialized Views)

===Business Stack===
Business tack layers are described in details in the following sections:
[DomainDrivenDesignBusinessDeveloperMentalModel#Application_Layer Application Layer]
[DomainDrivenDesignBusinessDeveloperMentalModel#Domain_Layer Domain Layer]
[CqRS_Part_II Infrastructure]
----
==Expressing Design using Custom Annotations==  
While reading the sample code You should notice multiple custom annotations, used to mark
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fannotations DDD Building Blocks]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fapplication%2Fannotation Application Layer objects]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fsagas Sagas]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents Events]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Command.java Commands]

Annotations are used to achieve three goals:
  * Tag code - visual analyzer (similar to "scaleable map") will be reading them and presenting design graph
  * Some custom annotations are annotated by Spring's annotation. In effects classes annotated by custom annotations gains Spring features (transactions and security). Using custom annotations decouples and globalizes Spring features.
  * CqRS engine (Event, Sagas) rely on some custom annotations.

All custom annotations will be described in details in later sections of this document.

----
==Inversion of Control techniques==
Application architecture of this sample rely in Inversion of Control principle - famous Hollywood rule: "Don't call Us, we will call You".

It is important to notice that Spring can be easily removed and all it's features can be implemented on Your own.

*Spring features are encapsulated by custom annotations and interfaces.
Implementing IoC features on Your own is described in PART II.*

===Dependency Injection===
DI is basic IoC technique. In this project DI is used only at the application level:
  * Injecting dependencies (Repositories, Services) to Command Handlers
  * Injecting dependencies (Repositories, Services) to Application Services -  If You want to use classic services approach without commands
  * Injecting dependencies (JDBC connection, Entity Manager) to repositories
  * Injecting dependencies (JDBC connection, Entity Manager) to Finders (presentation stack) 

We decided not to inject automatically dependencies to Aggregates. It could be done using Spring's @Configurable but we wanted to keep example magic clear. This trade-off makes easy rewrite our Leaven to different platform (Seam, EJB, etc.) 

===Events===
Events are stronger than DI technique of inverting control, because they allow to:
  * abstract number of dependencies (many listeners)
  * decouple from time arrow (asynchronous)

We have decided to implement own [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents Event Engine], because Spring's solution forces You to use Spring specific API.

Event engine contains:
  * two [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents annotations]
    * EventListener - for listener methods
    * EventListeners - for class containing listener methods - adds Spring Comonent features (DI)
  * just two [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents%2Fimpl impl classes]

So Events Engine can be easily enhanced to support asynchronous processing secured by persistent queue.

===Aspect Oriented Programming===
AOP is the strongest IoC technique used int the sample to provide:
  * transactions
  * security

You can use Command style or classic Application Service style. Simply use [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationService.java ApplicationService] or [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java CommandHandler] annotation - they both introduces Spring Security and Transaction Management features.

But implementing own "AOP" *is trivial* when using Command style. Simply edit [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/RunEnvironment.java RunEnvironment] class and add own features before and after running a handler.


----
----

=Application Layer= 

Application logic orchestrates scenario for "domain actors" who lives in lower layer. Application logic also takes care for security and transactions. Application logic can fire application events.
 
We will discuss all sample Application Layer artifacts focusing on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fapplication Sales Module].

==Commands/Services== 
Leaven supports two styles of implementing Application Logic.
Commands and App Services are technically totally different, but mentally can be considered as equivalent.
Commands are powerful because it's relatively easy to introduce own "AOP" programming model in clean and no-magic way. Using Spring you can achieve the same feature, but in transparent, magic way. So if magic scares You or You like to have full control - choose Commands style.

===Application Services===
At first let's look at the "service" style approach.
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/services/PurchaseApplicationService.java PurchaseApplicationService]

Characteristic:
  * Repository and Factory injection
  * ApplicationEvent Publisher injection
  * SystemUser - statefull (session scoped) application object injection
  * transactions and security features supported by Spring using custom [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationService.java ApplicationService] annotation
  * Service methods realizes parts of User Story/Use Case

Typical method implementation:
  * Load Aggregates from Repositories (or create in Factories)
  * Perform business scenario (sequence of aggregate calls)
  * Eventually create Application Event
  * Save Aggregates in Repository

===Commands and CommandHandlers===
Alternative to the class "service" style is a "command" style.
You always implement a pair - command and it's handler, for example:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/SubmitOrderCommand.java SubmitOrderCommand]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/handlers/SubmitOrderCommandHandler.java SubmitOrderCommandHandler]

or
* [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/CreateOrderCommand.java CreateOrderCommand]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/handlers/CreateOrderCommandHandler.java CreateOrderCommandHandler]


Conceptually two classes can be considered as a [http://en.wikipedia.org/wiki/Command_pattern Command Design Pattern]. In our case commands are sent from different Tier, so they can not contain any logic due the security and coupling reason. Therefore Command Design pattern is split to:
  * Command that just caries input data (kind of DTO)
  * CommandHandler that contains logic.

====Command====
Creating command is simple:
  * usually implement Serializable tagging interface because command may be send form remote client
  * add fields that holds command parameters
  * You *can* add [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Command.java @Command] annotation if You want to express following intentions:
    * Client is not interested in immediate result - command can be handled in asynchronous way. This is just a suggestion for a Server - it can support asynch. invocations. Use this mode when You want to optimize response time
    * Command is unique and sending it again is considered as a mistake (ex. nervous user clicking many times). Server stores some amount of commands (annotated as unique) that were ran, therefore it can optimize anti-flood mechanism. *This feature is just in sake of optimization. You must implement unique checking on the domain level* (ex. Order can not be accepted twice). Unique mechanism rely on equals method.
    * Unique command can specify how long it should be considered as unique.
====CommandHandler====
Creating a handler for a command is also pretty straightforward.
  * implement [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandler.java CommandHandler] interface. This interface is generic, so You must specify:
    * class of the Command that is handled - CqRS engine matches Command and Handlers by this parameter
    * result type - handling command may return something to the caller. Of course handler that handle asynchronous commands should return java.lang.Void (not the void keyword).
  * You *can* annotate handler with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java CommandHandlerAnnotation] if You wan to rely on automatic  Command2Handler matching. This annotation also introduces Spring features (Dependency Injection, Security and Transactions) to the handler so You don't need to worry about them.

Now implement logic just the same way as in classic [DomainDrivenDesignBusinessDeveloperMentalModel#Application_Services Application Service]: inject required dependencies and orchestrate part of the Use Case/user Story scenario in handle method based on parameters from the Command. You can also fire an Application Event.
----
==Application Event==
Application Events are characteristic to the specific Use Case/User Story. They model application (not domain) behavior.

To fire such an event simply:
  * inject [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/ApplicationEventPublisher.java ApplicationEventPublisher] to the Command Handler or Application Service
  * create event using any class
    * event usually carries some valuable ingormation
    * event class *can* be annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationEvent.java ApplicationEvent] annotations - consider this as a meta-data that will be analyzed by some cools tools we plan to publish

In our example application event [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/events/ProductAddedToOrderEvent.java ProductAddedToOrderEvent] models important fact of the application life cycle. Let's assume that in this sample we don't want to model this act on the domain model level.

Than, [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/presentation/listeners/ProductEventsListener.java one of the listeners] stores data about this fact in "spy model" used by the marketing division to do something evil.
----
==Listeners - Bounded Context and Context Mapper== 
Now we will discuss [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fapplication%2Flisteners Application Level Listeners].

One way to integrate modules (which are equal to Bounded Context in this Sample) is to call Application API of the another module.
This approach introduces coupling between Modules.

If You want to reduce coupling You can introduce events - one of the IoC techniques.
In this case:
  * one module fires Event (rather Domain Event, but Application Event is also possible)
  * other modules can listen to this event - each module can register many listeners per event.

Introducing events results in:
  * lose coupling (which is always good)
  * possibility to react in the asynchronous way
  * potability to introduce plugin oriented architecture - if You want to create flexible platform

===Bounded Context===
Consider class example by Udi Dahan.
There is a [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fcrm CRM Module] which contains a [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/crm/domain/Customer.java Customer Aggregate]. 

CRM module is about managing clients, this is completely differed Bounded Context than [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales sales Module].

CRM Client can have status changed. Requirement is:
 "when client status is changed to VIP than calculate x% of the rebate to all not-approved-yet orders"
Orders and Rebates are Sales Bounded Context concepts.
If we would perform this operation in the CRM module than we would break context boundary. CRM module would know about Sales details. probably everyone have worked on a systems we such a module-spaghetti was developed.

===Listener===

In this sample we want to avoid this kind of problems. Therefore CRM Client does it's own logic, than fires Event [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/crm/domain/events/CustomerStatusChangedEvent.java CustomerStatusChangedEvent]. *This is just a statement about the fact that took place*.

System can react in many ways on that statement. For example Sales module can register [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/listeners/CustomerStatusChangedListener.java CustomerStatusChangedListener] to perform *additional business logic*.

====Indicative mode====
Notice that Events are expressed in indicative model. Something has happen and we can not reject this fact. We can only perform additional processing.

This is opposite to the Commands, that are expressed in imperative mode and we can always reject a command.

====Asynchronous Event Processing====
Event listeners are just methods annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/infrastructure/events/EventListener.java EventListener]

You can specify asynchronous attribute to express intention that this logic can be calculated later.
*Always think if additional logic must be performed immediately?* Maybe not, than You can optimize request processing time.

Notice that in case of events, listener is the artifact that express asynch intention. It is opposite to the Commands, where commands express this intention and handler has nothing to say abut this matter.

====Application Listener as a Context Mapper and Anti-corruption Layer====
You can consider Application Event Listeners as a Context Mapers because them map concepts from different Bounded Contexts.
If Your Listeners are listening to the events from the legacy systems, they can be also considered as Anti-corruption Layer artifacts.

===Impl===
Application Level Event Listener can be implemented in two styles:
  * Perform logic using injected dependencies
  * Create a Command and run it via injected [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/RunEnvironment.java Run Environment]

----
==Sagas== 

Events are very powerful IoC technique, but has some limitations. You can use Event when dealing with dependent facts that took place in Your system. You mentally treat each Event and it's Listeners as an independent objects with no deterministic processing sequence.

What if sequence order matters? What of some process need to be "pushed" by many events?

You need to introduce a Saga mental model to orchestrate complex processes that contains multi-events sequence.

Sagas are just mentioned here to make layer description complete. Detailed description of Saga model is presented at the end of this document.
----
==Statefull Application Objects==
Sometimes You may need to model Application State.

Notice that:
  * state of the Domain Model should be persisted
  * state of the Client Tier is a different aspect

We are talking about Application Layer state. If You need to introduce state think if You are sure about that. Than think about persisting this model or using global, distributed cache. But if You decide to use Session as a storage mechanism than You have easy support. Just annotate classes with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationStatefullComponent.java ApplicationStatefullComponent] and You are done.

Spring will store objects of this class in Http Session. Spring also let You to inject this objects to Singleton Scoped objects using magic trick based on cunning proxy. For example our CommandHandlers or ApplicationServices are stateless singletons in sake of memory optimization.

Sample contains following Statefull Application Components:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/SystemUser.java SystemUser] - common object that represents user working with the system. You can inject this objects into CommandHandlers or ApplicationServices if You need to know who is performing operation. SystemUser is a application concept that abstract form domain entity. This object contains just ID of the domain entity therefore concept of domain user does not leak into whole code.
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/ClientBasket.java ClientBasket] is a metaphor of a shopping cart. In this sample We assume that Shopping cart is not a domain artifact nor client specific feature. Assumption is that this metaphor models application concept (but in some systems it may be a very important domain concept or maybe just some feature of some minor client app.).

----
----

=Domain Layer=
Now let's focus on the Sales Bounded Context and it's [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain Domain Layer].

We will go through all building blocks discussing design decisions and technical solutions.
==Entity==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/Product.java Product] is a sample entity.

Worth to notice:
  * In this case we don't need setters (technically JPA can work on private fields via refelction which is even faster that calling methods)
  * In general entity contains business methods - but on the other hand do not spread all business code on entities. [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderLine.java Order Line] is a sample Entity that performs business logic - calculates cost based on rebate policy
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/annotations/DomainEntity.java DomainEntity] is just a tagging annotation that will be used by cool visualisation tools we plan to publish

===Base class===
You *can* consider extending [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/BaseEntity.java BaseEntity].
*If You don't want to couple Your model with Leaven classes than simply rename and repackage this class*.

Remember that inheritance ins not just about pulling code up in the hierarchy! BaseEntity class is used as a polymorphic interface (in the meaning of "api", not java keyword) in the repositories, so we are in tune with [http://en.wikipedia.org/wiki/Liskov_substitution_principle Liskov Substitution Principle]. Therefore inheritance is justified.

Features of BaseEntity:
  * Optimistic Concurrency - @Version annotation
  * Store last modification date
  * Logic delete operation - change flag. You can use Hibernate Filters to automatically filter archived JPA entities
  * equals and hashcode
----
==Aggregate==
Sample Sales Bounded Context contains three Aggregates:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/Order.java Order]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/Invoice.java Invoice]
===Encapsulation===
Notice that:
  * Aggregates does not allow to modify all their properties via setters. It may have sense only in some cases.
  * Aggregate state is changed via business methods
  * Some business operations may be not valid in some state (ex. Order.submit()) - therefore they throw domain [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain%2Ferrors errors].
  * Not all getters makes sense.

====Inner state protection====
Notice that Invoice Aggregate method: getItems returns list of [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/InvoiceLine.java InvoiceLine] entities. But this list is also unidentifiable in order to protect Aggregate from being changed by outer code. 

====Inner model protection====
Notice that Order Aggregate method: addProduct takes as an argument Product Entity, than wraps it with OrderLine. OrderLine is Aggregate's inner implementation detail.

===Outside Projections using Value Objects===
In this sample we assume that Order model is unstable - we expect changes in near future. Therefore we want to reduce catastrophe area to Aggregate itself. Domain Expert is not sure about [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderLine.java Order Line] model.

Therefore [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderedProduct.java OrderedProduct] Value Object is introduced as an "adapter" that adopts inner aggregate model to the outer world.

Notice that method Order.getOrderedProducts transforms inner (unstable) aggregate model to the "outer interface" based on OrderedProduct Value Objects. Method return unidentifiable list because changes to this list does not make any sense.

===JPA aspects===
Aggregate is an entity from the JPA perspective. JPA can operate on private fields, so getters and setters are not necessary (using them makes sense only sometimes).

====Lazy Loading====
You may consider Eager loading of some aggregated objects. Some aggregated objects are always needed.

On the other hand Lazy loading does not hurt with <i>n+1 select problem</i> because in Business Model we usually load just couple on aggregates, so n is relatively small.

<code language="java">
  @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
  private List<OrderLine> items;
</code>

====Cascade Operations====
Cascade operations makes sense to most aggregated objects, so You must always consider adding this attribute.

===Base classes===
You *may* consider extending [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/BaseAggregateRoot.java BaseAggregateRoot] class.

*If You don't want to couple Your model with Leaven classes than simply rename and repackage this class*.

BaseAggregateRoot is based on BaseEntity - it adds common future, an injected [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/DomainEventPublisher.java DomainEventPublisher].

===Dependency Injection===
Aggregates are main work-horses of the domain. Therefore they need to delegate some work to dependencies (Domain Services, Policies, Specifications or DomainEventPublisher).

Aggregates *should not* create dependencies by their own. This simply kills testability.

We decided to perform injection manually in Factories and Repositories (described later). Factories and Repostories are the only places where Aggregate can be born, You should not call an Aggregate constructor. Therefore Factories and Repositories performs injection before they return an Aggregate.

Notice how[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/BaseAggregateRoot.java BaseAggregateRoot] class supports injection. setEventPubslisher can be called only once - in Repo or Factory. Calling it inside Application Layer will fail.

There are other ways to do this:
  * No setter, just custom injection annotation checked in Repo and factory - a little dirty in our opinion
  * @Configurable annotation - we do not want do use any magic in sake of architecture style portability. Besides, sometime we need to calculate (perform some business logic) to determine a Policy for example
  * Pass needed dependencies as Aggregate methods' parameters. Sometimes can be artificial, but sometimes makes sense. For example when dependency is need only in one method of the Aggregate. But in other hand - as we discuss later - very specific and used once Aggregate Methods should become a Domain Service.
----
==Value Objects==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fsharedcernel Shared Kernel] contains two examples of Value Objects: Money and Percentage. Both encapsulates representation of the value they protect.
Therefore You can chane money calculations to ultra-fast integers where fractions are handled with bytes shifting:)
Moreover Money encapsulates concept of the Currency. You can also add concept of currency ration date.
===Immutability===
VOs are immutable, so  You can pass them to another Aggregate without worrying about Side Effects. For example prices for OrderedProducts are used by InvoicingService to generate Invoice. Life is simple with immutability.
===Aggregate Inner State Projection===
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderedProduct.java OrderedProduct] Value Object is introduced as an "adapter" that adopts inner aggregate model to the outer world, because we assume that OrderLine model is unstable and will change in the future.


===Make explicit what is implicit===
VOs are little classes that makes difference.
Without VOs Your code suffers from Primitive Obsession Code Smell.
===Increase expression power===
Value objects are small artifacts but extremely increase power of domain expression. They enrich Ubiquitous Languages and helps understand details of the model. 
===JPA aspects=== 
Using VOs is very "cheap" from the perspective of JPA. You don't need any additional tables. Simple map them as @Embededable classes and use in Entitues/Aggregates ad @Embeded.

If You have more than one embeded VO in Entity You must use additional annotations:

<code language="java">
@Embedded
	@AttributeOverrides({
			@AttributeOverride(name = "value", column = @Column(name = "net_value")),
			@AttributeOverride(name = "currencyCode", column = @Column(name = "net_currencyCode")) })
	private Money net;

	@Embedded
	@AttributeOverrides({
		@AttributeOverride(name = "value", column = @Column(name = "gros_value")),
		@AttributeOverride(name = "currencyCode", column = @Column(name = "gros_currencyCode")) })
	private Money gros;
</code>

Alternatively You can provide special Naming Strategy in Hibenrate.

----
==Factory==
Sample contains two factories: [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderFactory.java OrderFactory] and InvoiceFactory.

Factories are annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/annotations/DomainFactory.java DomainFactory] annotation. This annotation introduces Spring features - factory becomes a Spring bean, therefore You can inject dependencies into the factory and factory can be injected into CommandHandlers.

Now we will discuss responsibility scope of DDD Factories.

===Validation===
Factory is responsible for providing valid Aggregates. Invalid Aggregate can not exist in memory. OrderFactory is responsible for validating 
"components" that build Order - in this sample it checks Client and eventually throws [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/errors/OrderCreationException.java Domain Error].
===Injecting Factories into Command Handlers/Application Services
Factories are need to create Aggregates, therefore You will inject them into Command handlers or other places. It is possible because factory is a Spring Bean
===Injecting into Factory===
Factory may also need some dependencies. For example Repositories to be able to check something.

For example OrderFactory adds gratis products to newly created order. Knowledge about gratis comes from DomainService or Repository.

Another example is RebatePolictFactory in OrderFactory to determine rebate.

===Dependency Injection Responsibility===
Aggregates needs dependencies. We decided that Factories and Repositories are responsible for providing them.

In sample code OrderRepository is responsible for injecting RebatePolicy.

There are some very common dependencies, like DomainEventsPublisher that are injected by special [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/support/InjectorHelper.java InjectorHelper].
 
===Part of business logic (Assembling objects)===

Factory is responsible for some domain logic:
  * calculates dependencies - Rebate Policy
  * add gratis producst
Therefore it is a First Class Citizen in DDD Buildng Blocks World.

Read great [http://misko.hevery.com/2008/08/21/where-have-all-the-singletons-gone post] by Miško Hevery that explains three faces of the coupling:
  * collaboration
  * construction
  * call

Factories lighten application logic layer by taking construction coupling.


===Increase testability=== 

If You construct Aggregate dependencies in factories and than inject them to the Aggregate You gain another feature - higher testability. Thanks factories, Aggregates don't have to use new operator (except inner data structures). This means You can easily mock dependencies when unit testing.

----
==Repository==

Project contains few sample Repositories, that are implemented in the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Finfrastructure%2Frepositories%2Fjpa Infrastructure Layer].

Repository is an abstraction of the Aggregate/Entity persistence. In general Aggregate parts may origin form different sources.

Repository manages aggregate, which means it mus load and save. Don'p pollute repositories with dozens of search method - that's the responsibility of the second stack - a Presentation Stack.

Of course repository will contain business search methods, like: find draft Orders of the given Client, because we want to apply rebate for them.

===Responsibilities===

In general Repository is also responsible for stuff that Factory does: a Dependency Injection.

===Base Classes=== 

There are base classes for both Entity and Aggregate repositories in [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Frepo%2Fjpa common DDD goodies].

Impl is based on the famous [http://www.ibm.com/developerworks/java/library/j-genericdao/index.html Generic DAO] by Per Mellqvist.

----
==Domain Services==
Sometimes it is not natural to just stick some method to the Aggregate.
Moreover we don't want to our Aggregates become a God Classes. 8k lines of code monster that knows everything and knows everyone.

There is a [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/InvoicingService.java InvoicingService] sample Domain Service that handles creating Invoices.

We certainly don't want to add this feature to the Order Aggregate.

Domain Service is annotated by [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/annotations/DomainService.java DomainService] annotation that introduces Spring Bean features. therefore our Domain Service can be injected and we can inject dependencies to the service (ex. Repositories).

As we can see, InvoicingService looks at the Order Aggregate through a ValueObject "projection" mentioned earlier.

===Responsibility Driven Design Transformers===
Great book [http://www.amazon.com/Object-Design-Roles-Responsibilities-Collaborations/dp/0201379430 Responsibility Driven Design] by Rebecca Wirfs-Brock describes standard Building Blocks - more abstract than Evans' DDD BB. 

InvoicingService can be considered as a Transformer role class, that transforms Orders to Invoices.

===When to introduce: simple rule of the thumb=== 

Simple rule of the thumb for beginners. You probably wont miss much if create Domain Services instead of Aggregate methods for operations that are used on one Use Case/user Story.

It it a procedural way of thinking but keeps Aggregates coherent and lousily coupled.

That's just a rule for the newbies, so it intuition tells when to break it. 

----
==Policy==

Technically Policy is just an old, good [http://en.wikipedia.org/wiki/Strategy_design_pattern Strategy Design Pattern].

In our sample project we have two behaviors that varies a lot:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/RebatePolicy.java Rebate Counting] - depends on client, product, whole order, history etc
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/TaxPolicy.java Tax Counting] - depends on client's country, seller country etc

===Make explicit what is implicit===
We want to express those very important domain concepts in the model and treat them as First Class Citizens.

===Supple Design===
Introducing policy opens design for further extension. It also encapsulates complex logic in separated places:
  * Rebate counting resides in specific [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain%2Fpolicies%2Frebate implementations]
  * Rebate choosing based on logged user resides in [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/RebatePolicyFactory.java RebatePolicyFactory]
  * Calling rebate is managed by Order Aggregate and delegated to the Order Lines

===Decorating technique===
Suppose we have VIP rebate and Winter rebate. What if VIP buys in winter? Suppose our system composes rebates. Should we introduce a third class to the model?

Sure not! All You need to do is to introduce a [http://en.wikipedia.org/wiki/Decorator_design_pattern Decorator Design Pattern].

[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain%2Fpolicies%2Frebate%2Fdecorators Sample decorators].

===Functional style===

Strategy design pattern semantically is similar to the functional style programming. Concept is the same: an operation is as First Class Citizen. In OO language FCC is an objects. So we simply pack operations into objects with only one method which is a signal to the object saying "execute yourself"  

===Injecting=== 

In our example Order Policy is injected to the order Aggregate by the Order Repository and Order Factory.

Another example:
Tax Policy is passed to the Invoicing Service as a method parameter.

----

==Specification==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/handlers/SubmitOrderCommandHandler.java SubmitOrderCommandHandler] attempts to submit Order and generate Invoice.

But there are complex constrains that must be met before Order can be submitted. If you struggle to model constrains that are build by many criterion which are arranged in logic tree than You may consider using a [http://en.wikipedia.org/wiki/Specification_pattern Specification Pattern]. 

Sample contains [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain%2Fspecification%2Forder Order Specifications] based on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fsharedcernel%2Fspecification library generic specification]. 

===Supple Design in Runtime===

Power of the specification is that it can be assembled late in the runtime based on the actual context.

Method SubmitOrderCommandHandler.generateSpecification can be refactored to the factory.

===Further extension===

If needed You may extend Specification so that it collects errors.

----
==Domain Events==
In one of the previous chapters we have discussed Application Events. technically Domain Events are the same. Difference is one the mental level - Domain Events model facts that takes place in domain model.

[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/BaseAggregateRoot.java BaseAggregateRoot] contains [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/DomainEventPublisher.java DomainEventPublisher] object which is injected via Repo or Factory. 

Firing event:
  * inject DomainEventPublisher
  * create objects of any class that contains valuable information
  * call publish on publisher

Sample event publishing: submit method of [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/Order.java Order] Aggregate.

Listening events:
  * annotate listener method with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/infrastructure/events/EventListener.java EventListener]
    * Event listener may express intention that it is not interested in immediate execution - asynchronous attribute
  * annotate class containing listener method with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/infrastructure/events/EventListeners.java EventListeners] - that will register Spring bean and introduce Dependency Injection support

Now we will discuss motivations that promotes using Domain Events
===Decoupling===
Events introduce Bounded Contexts decoupling. Context does not know about each other.

Events introduces Technical decoupling. Domain Building blocks does not know about technical listeners (ex. mail/sms senders, facebook publishers;)

Sample: [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/infrastructure/events/listeners/domain/OrderSubmittedListener.java OrderSubmittedListener] that fakes sending mail.
===Optimization===
Some listeners may be executed in asynchronous way which reduces request processing time.

Sample: [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/infrastructure/events/listeners/domain/OrderSubmittedListener.java OrderSubmittedListener] that fakes sending mail can be annotated to work in asynch mode. 
===Plugin oriented architecture===
Listeners may introduce new features without need to touch core code.
===Updating read model===
Domain Events can be used to update [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fpresentation Presentation Model].

You can use this technique when presentation model is implemented as a separate, dedicated model (not Views). You can introduce many presentation model (each per specific case) that are updated by the same Event - just add dedicated updating Listener per model.

In [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/presentation/listeners/ProductEventsListener.java this sample] Listener works on Application Event, but idea is the same.

===Event Sourcing===
Domain Events may be stored as a behavioral model. Loading Aggregate loads all it'e events and executes them on a given aggregate. In this case Presentation model must be updated via updating listeners discussed in previous section.
----
----
=Saga=
Great Saga introduction by Udi Dahan: [http://www.udidahan.com/2009/04/20/saga-persistence-and-event-driven-architectures/ Saga Persistence and Event-Driven Architectures]
==Complex process orchestration==
In general use Saga when You need to orchestrate process that is pushed by many events. Using Saga You can model partial state change of the bigger process - state change triggered by events.
==Persistent multi-listener==

Saga has persistent state and listen to many events.

[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fsagas Saga Engine] is described in details in [PART II]. General idea is:
  * Engine catches event
  * Engines finds Loaders that are interested in this event
  * Engine asks found Loaders to load/create persistent Mementos
  * Engine feeds relevant Sagas with Mementos
  * Engine calls Saga event handlers
  * Sagas change their state (Memento)
  * Mementos are persisted
  * Sagas may be done

Above scenario is a technical point of view, but it is good to understand it at this level. Business Developer does not have to implement technical steps, they are provided by the Engine. Business 

Developers focuses on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fsagas Saga API] and following domain artifacts:

===Logic===
Create class that implements Saga logic. In this class we focus only on business logic, don't have to think about engine.
Sample:

Extends base class and use API Annotation.

Each saga listener method must be annotated.

Some (maybe all) methods may try to finish this saga.

TODO

===Data - Memento===

Saga data is simple [http://en.wikipedia.org/wiki/Memento_pattern Memento Design Pattern].

Idea is that Saga class is stateless, state is delegated to the memento.

TODO

===Loader===

Saga loader focuses on funding right memento for Saga Logic based on event. In general finding Memento may rely on different parameters of different events. For each event instance there may be many matching finders, therefore many mementos, so one event instance can push many sagas.

TODO

==Saga makes explicit what is implicit==
Sage models very complex processes. Modeling them instead of trying to pretend that they are not so complex is essential for chaos management in the model and code.